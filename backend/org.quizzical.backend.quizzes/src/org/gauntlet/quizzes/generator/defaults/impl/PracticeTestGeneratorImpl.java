package org.gauntlet.quizzes.generator.defaults.impl;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.gauntlet.core.api.ApplicationException;
import org.gauntlet.core.api.dao.NoSuchModelException;
import org.gauntlet.core.commons.util.jpa.JPAEntityUtil;
import org.gauntlet.problems.api.dao.IProblemDAOService;
import org.gauntlet.problems.api.model.Problem;
import org.gauntlet.problems.api.model.ProblemCategory;
import org.gauntlet.problems.api.model.ProblemDifficulty;
import org.osgi.framework.BundleContext;
import org.osgi.service.log.LogService;
import org.quizzical.backend.security.api.model.user.User;
import org.quizzical.backend.testdesign.api.dao.ITestDesignTemplateDAOService;
import org.quizzical.backend.testdesign.api.model.TestDesignTemplate;
import org.quizzical.backend.testdesign.api.model.TestDesignTemplateItem;
import org.quizzical.backend.testdesign.api.model.TestDesignTemplateItemDifficultyType;
import org.quizzical.backend.testdesign.api.model.TestDesignTemplateSection;
import org.quizzical.backend.testdesign.model.jpa.JPATestDesignTemplateContentSubType;
import org.quizzical.backend.testdesign.model.jpa.JPATestDesignTemplateItem;
import org.gauntlet.quizzes.api.dao.IQuizDAOService;
import org.gauntlet.quizzes.api.model.Constants;
import org.gauntlet.quizzes.api.model.Quiz;
import org.gauntlet.quizzes.api.model.QuizProblem;
import org.gauntlet.quizzes.api.model.QuizType;
import org.gauntlet.quizzes.generator.api.IQuizGeneratorService;
import org.gauntlet.quizzes.generator.api.model.QuizGenerationParameters;


public class PracticeTestGeneratorImpl implements IQuizGeneratorService { 
	private static final DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy");
	private static final DateFormat timeFormat = new SimpleDateFormat("HH:mm:ss");

	private volatile LogService logger;
	
	private volatile BundleContext ctx;

	private volatile IQuizDAOService quizDAOService;
	
	private volatile IProblemDAOService problemDAOService;
	
	private volatile ITestDesignTemplateDAOService testTemplateService;
	
	@Override
	public Quiz generate(User user, QuizGenerationParameters params) throws ApplicationException {
		TestDesignTemplateSection nonCalSec = null;
		TestDesignTemplateSection calSec = null;

		final TestDesignTemplate pt1 = testTemplateService.getByCode("PracticeTest1");
		final List<TestDesignTemplateSection> sections = pt1.getOrderedSections();
		nonCalSec = sections.get(0);
		calSec = sections.get(1);

		//=== Init params
		final QuizType quizType = quizDAOService.provideQuizType(new QuizType(
				Constants.QUIZ_TYPE_GENERATED_NAME,
				Constants.QUIZ_TYPE_GENERATED_CODE));
		final String quizCode = String.format(
				"generated-%s-%d-%d",
				params.getGeneratorType(),
				params.getQuizSize(),
				System.currentTimeMillis());
		final Date quizDateTime = Calendar.getInstance().getTime();
		final String quizName = String.format(
				"Generated by TestDesign \"%s\" at %s on %s",
				pt1.getCode(),
				timeFormat.format(quizDateTime),
				dateFormat.format(quizDateTime));
		
		//=== NonCalc
		Map<Long,Problem> includedProblemIds = new HashMap<>();
		final List<QuizProblem> nonCalcQuizProblems = nonCalSec.getOrderedItems()
				.parallelStream()
        		.map(item -> {
        			QuizProblem qp = null;
        			try {
						ProblemCategory cat = problemDAOService.getProblemCategoryByCode(item.getContentSubType().getCode());
						ProblemDifficulty diff = problemDAOService.getProblemDifficultyByCode(getDifficultyCode(item.getDifficultyType()));
						
						int count = problemDAOService.countByDifficultyAndCategoryNotInIn(diff.getId(), cat.getId(), includedProblemIds.keySet());
						int randomOffset = generateRandowOffset(count);
						
						final List<Problem> problems = problemDAOService.findByDifficultyAndCategoryNotInIn(diff.getId(), cat.getId(), includedProblemIds.keySet(),randomOffset,1);
						if (problems.isEmpty())
							throw new RuntimeException(String.format("Test Item %s cannot match a problem",item.getCode()));
						final Problem problem = problems.iterator().next();
						
						includedProblemIds.put(problem.getId(),problem);
						
						qp = new QuizProblem(
								"",
								String.format("%s-%s", quizCode, problem.getCode()),
								item.getOrdinal(),
								problem.getId(),
								problem);
						qp.setSectionOrdinal(item.getSection().getOrdinal());
					} catch (Exception e) {
						throw new RuntimeException(String.format("Error processing TestDesign item %s",item.getCode()));
					}
        			
        			return qp;
    	    	})
        		.collect(Collectors.toList());
		final Problem startNonCalcProblem = problemDAOService.getByCode(org.gauntlet.problems.api.model.Constants.SYSTEM_PROBLEM_START_NON_CALC_SEC);
		QuizProblem startNonCalcQuizProblem = new QuizProblem(
				"",
				String.format("%s-%s", quizCode, startNonCalcProblem.getCode()),
				-1,
				startNonCalcProblem.getId(),
				startNonCalcProblem);
		startNonCalcQuizProblem.setSectionOrdinal(calSec.getOrdinal());
		nonCalcQuizProblems.add(startNonCalcQuizProblem);
		
		
		//=== Calc
		final List<QuizProblem> calcQuizProblems = calSec.getOrderedItems()
				.parallelStream()
        		.map(item -> {
        			QuizProblem qp = null;
        			try {
						final ProblemCategory cat = problemDAOService.getProblemCategoryByCode(item.getContentSubType().getCode());
						final ProblemDifficulty diff = problemDAOService.getProblemDifficultyByCode(getDifficultyCode(item.getDifficultyType()));
						
						final int count = problemDAOService.countByDifficultyAndCategoryNotInIn(diff.getId(), cat.getId(), includedProblemIds.keySet());
						int randomOffset = generateRandowOffset(count);
						
						final List<Problem> problems = problemDAOService.findByDifficultyAndCategoryNotInIn(diff.getId(), cat.getId(), includedProblemIds.keySet(),randomOffset,1);
						if (problems.isEmpty())
							throw new RuntimeException(String.format("Test Item %s cannot match a problem",item.getCode()));
						final Problem problem = problems.iterator().next();
						
						includedProblemIds.put(problem.getId(),problem);
						
						qp = new QuizProblem(
								"",
								String.format("%s-%s", quizCode, problem.getCode()),
								item.getOrdinal(),
								problem.getId(),
								problem);
						qp.setSectionOrdinal(item.getSection().getOrdinal());
					} catch (Exception e) {
						throw new RuntimeException(String.format("Error processing TestDesign item %s",item.getCode()));
					}
        			
        			return qp;
    	    	})
        		.collect(Collectors.toList());	
		
		final Problem startCalcProblem = problemDAOService.getByCode(org.gauntlet.problems.api.model.Constants.SYSTEM_PROBLEM_START_CALC_SEC);
		QuizProblem startCalcQuizProblem = new QuizProblem(
				"",
				String.format("%s-%s", quizCode, startCalcProblem.getCode()),
				-1,
				startCalcProblem.getId(),
				startCalcProblem);
		startCalcQuizProblem.setSectionOrdinal(calSec.getOrdinal());
		calcQuizProblems.add(startCalcQuizProblem);
		
		final List<QuizProblem> orderedQuizProblems = Stream.concat(nonCalcQuizProblems.stream(), calcQuizProblems.stream()).collect(Collectors.toList());
		Collections.sort(orderedQuizProblems, new Comparator<QuizProblem>() {
			@Override
			public int compare(QuizProblem o1, QuizProblem o2) {
				if  (((o1.getSectionOrdinal() < o2.getSectionOrdinal())
						|| o1.getSectionOrdinal() == o2.getSectionOrdinal()) && (
								(o1.getOrdinal() < o2.getOrdinal()))
							||  (o1.getOrdinal() == -1 && o2.getOrdinal() > -1)
						)
					return -1;
				else if (((o1.getSectionOrdinal() > o2.getSectionOrdinal())
						|| o1.getSectionOrdinal() == o2.getSectionOrdinal()) && (
								(o1.getOrdinal() > o2.getOrdinal())
							||  (o1.getOrdinal() > -1 && o2.getOrdinal() == -1)
								)
						)
					return  1;
				else 
					return 0;//they must be the same
			}
		});
		
		
		final Quiz quiz = new Quiz();
		quiz.setUserId(user.getId());
		quiz.setCode(quizCode);
		quiz.setName(quizName);
		quiz.setQuizType(quizType);
		quiz.setQuestions(orderedQuizProblems);
		
		final Quiz persistedQuiz = quizDAOService.provide(user, quiz);
		persistedQuiz.getQuestions()
			.stream()
			.forEach(question -> {
				question.setProblem(includedProblemIds.get(question.getProblemId()));
				question.setQuiz(quiz);
			});
		
		return persistedQuiz;
	}

	private int generateRandowOffset(int count) {
		return ThreadLocalRandom.current().nextInt(0, count-1);
	}

	private String getDifficultyCode(TestDesignTemplateItemDifficultyType difficultyType) {
		if (difficultyType.equals(TestDesignTemplateItemDifficultyType.EASY))
			return "Easy";
		else if (difficultyType.equals(TestDesignTemplateItemDifficultyType.EASY))
			return "Medium";
		else
			return "Hard";
	}
}